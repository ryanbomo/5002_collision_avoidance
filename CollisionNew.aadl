package CollisionNew

public
	with Base_Types;
	process CollisionAlgorithm
		features
      ownAlt: in data port Base_Types::float;
      ownVertVel: in data port Base_Types::float;
      ownVertAcc: in data port Base_Types::float;
      intAlt: in data port Base_Types::float;
      intVertVel: in data port Base_Types::float;
      intVertAcc: in data port Base_Types::float;
      ownLocation: in data port Base_Types::integer;
      annex agree{**
      		eq t: real; -- time
      		eq nextOwnAlt: real; -- changed altitude
      		eq ownVVel:real;
      		eq ownVAcc:real;
      		eq goesUp: bool;
      		eq goesDown:bool;
      		eq locationInt:int;
      		const east: int =1;
      		const west: int =2;
      		assume"positive altitude": ownAlt>1.0;
      		assume"positive intruder altitude": intAlt>1.0;
      		assume"positive time": t>1.0;
      		assume"own location": ownLocation = east or ownLocation = west;
      		assume"location doesnt change": ownLocation = pre(ownLocation);
      		assume"previous altitude doesnt change": ownAlt = pre(ownAlt);
      		--assume"time monotonically increases": t = pre(t) + 0.5 ;
      		--guarantee"safe no manuevers needed": true->(ownAlt-intAlt)>50.0 or (intAlt-ownAlt)>50.0 ;
      		--guarantee"own flight at lower altitude goes down": true -> goesDown;
      		--guarantee"own flight at higher altitude goes up": true-> goesUp;
      	
      **};
		
	end CollisionAlgorithm;
	
	process implementation CollisionAlgorithm.NewCollisionAlgorithm_impl
		annex agree{**
				assign locationInt = if ownLocation= east then west else east;
				-- accelaration change based on altitude and location
				assign ownVAcc = 10.0-> if ((ownAlt-intAlt)>0.0 and (ownAlt-intAlt)<50.0) then ownVertVel + 50.0 
									else if ((intAlt-ownAlt)>0.0 and (intAlt-ownAlt)<50.0) then ownVertVel - 50.0 
									else if (intAlt=ownAlt) and (ownLocation = east) then ownVertVel - 50.0
									else if (intAlt=ownAlt) and (ownLocation = west) then ownVertVel + 50.0
									else 10.0;
									
				-- velocity change based on altitude and location			
				assign ownVVel = 10.0->if ((ownAlt-intAlt)>0.0 and (ownAlt-intAlt)<50.0) then 
										ownVertVel + Nodes.multiplication(ownVAcc, t)
									else if ((intAlt-ownAlt)>0.0 and (intAlt-ownAlt)<50.0) then 
										ownVertVel - Nodes.multiplication(ownVAcc, t)
									else if (intAlt=ownAlt) and (ownLocation = east) then 
										ownVertVel - Nodes.multiplication(ownVAcc, t)
									else if (intAlt=ownAlt) and (ownLocation = west) then 
										ownVertVel + Nodes.multiplication(ownVAcc, t)
									else 10.0;
				
				assign nextOwnAlt = ownAlt-> Nodes.multiplication(ownVVel, t);
				assign goesDown = true->if (ownAlt<intAlt) and nextOwnAlt<ownAlt then true 
										else if (intAlt=ownAlt) and (ownLocation = east) and nextOwnAlt<ownAlt then true 
										else false; 
				assign goesUp = true->if (ownAlt>intAlt) and nextOwnAlt>ownAlt then true 
										else if (intAlt=ownAlt) and (ownLocation = west) and nextOwnAlt>ownAlt then true 
										else false; 
										
					
		**};
	end CollisionAlgorithm.NewCollisionAlgorithm_impl;

end CollisionNew;